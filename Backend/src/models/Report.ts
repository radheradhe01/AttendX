import mongoose, { Document, Schema } from 'mongoose';

/**
 * Report Model - Generated reports for various ERP modules
 * Stores report metadata and generation history
 */

export interface IReport extends Document {
  _id: string;
  reportType: 'attendance' | 'academic' | 'financial' | 'student' | 'faculty' | 'course';
  title: string;
  description: string;
  generatedBy: mongoose.Types.ObjectId; // User who generated the report
  parameters: {
    startDate?: Date;
    endDate?: Date;
    department?: string;
    course?: string;
    student?: string;
    faculty?: string;
    semester?: number;
    year?: number;
    format: 'pdf' | 'csv' | 'excel';
  };
  fileInfo: {
    fileName: string;
    filePath: string;
    fileSize: number; // in bytes
    mimeType: string;
    downloadCount: number;
  };
  status: 'generating' | 'completed' | 'failed';
  errorMessage?: string;
  generatedAt: Date;
  expiresAt: Date; // Reports expire after 30 days
  isPublic: boolean; // Whether report can be accessed by others
  tags: string[];
  createdAt: Date;
  updatedAt: Date;
}

const reportSchema = new Schema<IReport>({
  reportType: {
    type: String,
    required: [true, 'Report type is required'],
    enum: ['attendance', 'academic', 'financial', 'student', 'faculty', 'course'],
  },
  title: {
    type: String,
    required: [true, 'Report title is required'],
    trim: true,
    maxlength: [200, 'Title cannot exceed 200 characters'],
  },
  description: {
    type: String,
    required: [true, 'Report description is required'],
    trim: true,
    maxlength: [500, 'Description cannot exceed 500 characters'],
  },
  generatedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Generated by field is required'],
  },
  parameters: {
    startDate: {
      type: Date,
    },
    endDate: {
      type: Date,
    },
    department: {
      type: String,
      trim: true,
    },
    course: {
      type: String,
      trim: true,
    },
    student: {
      type: String,
      trim: true,
    },
    faculty: {
      type: String,
      trim: true,
    },
    semester: {
      type: Number,
      min: [1, 'Semester must be at least 1'],
      max: [8, 'Semester cannot exceed 8'],
    },
    year: {
      type: Number,
      min: [1, 'Year must be at least 1'],
      max: [4, 'Year cannot exceed 4'],
    },
    format: {
      type: String,
      required: [true, 'Report format is required'],
      enum: ['pdf', 'csv', 'excel'],
    },
  },
  fileInfo: {
    fileName: {
      type: String,
      required: [true, 'File name is required'],
      trim: true,
    },
    filePath: {
      type: String,
      required: [true, 'File path is required'],
      trim: true,
    },
    fileSize: {
      type: Number,
      required: [true, 'File size is required'],
      min: [0, 'File size cannot be negative'],
    },
    mimeType: {
      type: String,
      required: [true, 'MIME type is required'],
      trim: true,
    },
    downloadCount: {
      type: Number,
      default: 0,
      min: [0, 'Download count cannot be negative'],
    },
  },
  status: {
    type: String,
    enum: ['generating', 'completed', 'failed'],
    required: [true, 'Status is required'],
    default: 'generating',
  },
  errorMessage: {
    type: String,
    trim: true,
  },
  generatedAt: {
    type: Date,
    default: Date.now,
  },
  expiresAt: {
    type: Date,
    required: [true, 'Expiration date is required'],
    default: () => new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days from now
  },
  isPublic: {
    type: Boolean,
    default: false,
  },
  tags: [{
    type: String,
    trim: true,
    lowercase: true,
  }],
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true },
});

// Indexes for better query performance
reportSchema.index({ reportType: 1 });
reportSchema.index({ generatedBy: 1 });
reportSchema.index({ status: 1 });
reportSchema.index({ generatedAt: -1 });
reportSchema.index({ expiresAt: 1 });
reportSchema.index({ tags: 1 });
reportSchema.index({ isPublic: 1 });

// Virtual for file size in human readable format
reportSchema.virtual('fileSizeFormatted').get(function () {
  const bytes = this.fileInfo.fileSize;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  
  if (bytes === 0) return '0 Bytes';
  
  const i = Math.floor(Math.log(bytes) / Math.log(1024));
  return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
});

// Virtual for report age in days
reportSchema.virtual('ageInDays').get(function () {
  const now = new Date();
  const diffTime = Math.abs(now.getTime() - this.generatedAt.getTime());
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
});

// Virtual for days until expiration
reportSchema.virtual('daysUntilExpiration').get(function () {
  const now = new Date();
  const diffTime = this.expiresAt.getTime() - now.getTime();
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
});

// Virtual for download URL
reportSchema.virtual('downloadUrl').get(function () {
  return `/api/reports/${this._id}/download`;
});

// Pre-save middleware to validate date ranges
reportSchema.pre('save', function (next) {
  if (this.parameters.startDate && this.parameters.endDate) {
    if (this.parameters.startDate > this.parameters.endDate) {
      return next(new Error('Start date cannot be after end date'));
    }
  }
  next();
});

// Static method to find reports by type and date range
reportSchema.statics.findByTypeAndDateRange = function (
  reportType: string, 
  startDate: Date, 
  endDate: Date
) {
  return this.find({
    reportType,
    generatedAt: { $gte: startDate, $lte: endDate },
    status: 'completed'
  }).populate('generatedBy', 'email role');
};

// Static method to find expired reports
reportSchema.statics.findExpired = function () {
  return this.find({
    expiresAt: { $lt: new Date() }
  });
};

// Static method to get report statistics
reportSchema.statics.getReportStats = function (userId: string) {
  return this.aggregate([
    {
      $match: {
        generatedBy: new mongoose.Types.ObjectId(userId)
      }
    },
    {
      $group: {
        _id: '$reportType',
        count: { $sum: 1 },
        totalSize: { $sum: '$fileInfo.fileSize' },
        totalDownloads: { $sum: '$fileInfo.downloadCount' }
      }
    }
  ]);
};

// Static method to increment download count
reportSchema.statics.incrementDownloadCount = function (reportId: string) {
  return this.findByIdAndUpdate(
    reportId,
    { $inc: { 'fileInfo.downloadCount': 1 } },
    { new: true }
  );
};

export const Report = mongoose.model<IReport>('Report', reportSchema);
